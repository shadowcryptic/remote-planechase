<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Display Debug</title>
    <style>
      html,
      body {
        margin: 0;
        width: 100%;
        height: 100%;
        background: #000;
        overflow: hidden;
      }
      body {
        display: grid;
        place-items: center;
      }

      .deck {
        width: 680px;
        height: 488px;
        position: relative;
      }

.card{
  position: absolute;
  top: 50%;
  left: 50%;

  /* TRUE visual centering */
  transform: translate(-50%, -50%) rotate(90deg);

  /* shrink-only (rotated => swap limits) */
  max-width: 488px;
  max-height: 680px;
  width: auto;
  height: auto;
  object-fit: contain;

  border-radius: 14px;
  box-shadow: 0 18px 50px rgba(0,0,0,0.55);
  user-select: none;
  -webkit-user-drag: none;
  will-change: transform;
}


.top{
  z-index: 2;
  transform: translate(-50%, -50%) rotate(90deg) translateX(0);
}

.top.to-right{
  transition: transform 260ms cubic-bezier(.2,.8,.2,1);
  transform: translate(-50%, -50%) rotate(90deg) translateX(740px);
}

.top.to-left-under{
  z-index: 1;
  transition: transform 360ms cubic-bezier(.2,.8,.2,1);
  transform: translate(-50%, -50%) rotate(90deg) translateX(-740px) translateZ(-120px) scale(0.96);
}

.top.back-to-center-under{
  z-index: 1;
  transition: transform 260ms cubic-bezier(.2,.8,.2,1);
  transform: translate(-50%, -50%) rotate(90deg) translateX(0) translateZ(-120px) scale(0.96);
}

.under{
  z-index: 1;
  transform: translate(-50%, -50%) rotate(90deg);
}


      @media (prefers-reduced-motion: reduce) {
        .top.to-right,
        .top.to-left-under,
        .top.back-to-center-under {
          transition: none;
        }
      }
    </style>
  </head>
  <body>
    <div id="status">Bootingâ€¦</div>
    <pre id="dump"></pre>
    <div class="deck">
      <img id="cardUnder" class="card under" alt="" />
      <img id="cardTop" class="card top" alt="" />
    </div>

    <script type="module">
      import {
        db,
        doc,
        onSnapshot,
        setDoc,
        runTransaction,
        serverTimestamp,
      } from "./common.js";

      const roomRef = doc(db, "rooms", "my-room");

      async function loadDeck() {
        const res = await fetch("./deck.json", { cache: "no-store" });
        if (!res.ok) throw new Error("Failed to load deck.json");
        const data = await res.json();
        return Array.isArray(data.deck) ? data.deck : [];
      }

      function shuffledIndices(n) {
        const a = [];
        for (let i = 0; i < n; i++) a.push(i);
        for (let i = n - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          const tmp = a[i];
          a[i] = a[j];
          a[j] = tmp;
        }
        return a;
      }

      const a = document.getElementById("cardUnder");
      const b = document.getElementById("cardTop");

      let topEl = a;
      let underEl = b;
      let currentUrl = "";

      // Initialize layer classes
      topEl.classList.add("top");
      underEl.classList.add("under");

      function setTopInstant(url) {
        topEl.src = url;
        underEl.src = url; // keep it consistent at start
        currentUrl = url;
      }

      const deckUrls = await loadDeck();

      // Ensure Firestore has an order matching deck length (runtime shuffle)
      await runTransaction(db, async (tx) => {
        const snap = await tx.get(roomRef);
        const existing = snap.exists() ? snap.data() : {};
        const order = Array.isArray(existing.order) ? existing.order : [];

        if (order.length !== deckUrls.length) {
          tx.set(
            roomRef,
            {
              order: shuffledIndices(deckUrls.length),
              idx: 0,
              shuffledAt: serverTimestamp(),
            },
            { merge: true },
          );
        }
      });

      let animating = false;
      let queuedUrl = "";

      function setInstant(url) {
        topEl.src = url;
        underEl.src = url;
        currentUrl = url;
      }

      function waitTransition(el) {
        return new Promise((resolve) => {
          const onEnd = (e) => {
            if (e.propertyName !== "transform") return;
            el.removeEventListener("transitionend", onEnd);
            resolve();
          };
          el.addEventListener("transitionend", onEnd);
        });
      }

      async function animateTo(nextUrl) {
        if (!nextUrl || nextUrl === currentUrl) return;

        // If user clicks quickly, keep only the latest requested card
        if (animating) {
          queuedUrl = nextUrl;
          return;
        }
        animating = true;

        // 1) Put the NEXT card underneath (revealed when top slides right)
        underEl.src = nextUrl;

        // Ensure we start from a clean class state
        topEl.classList.remove(
          "to-right",
          "to-left-under",
          "back-to-center-under",
        );

        // 2) Move top card to the right (still on top)
        // (force a layout so transition always triggers)
        void topEl.offsetWidth;
        topEl.classList.add("to-right");
        await waitTransition(topEl);

        // 3) Now the physical "tuck under": switch z-index and swap which image is where.
        // After this moment, the NEW card is the visible top card.
        const oldUrl = currentUrl;
        currentUrl = nextUrl;

        // Make the new card be the top layer visually:
        // swap element references so underEl becomes the new top.
        const oldTop = topEl;
        topEl = underEl;
        underEl = oldTop;

        // Ensure classes match the new roles
        topEl.className = "card top"; // new top, stays centered
        underEl.className = "card under top"; // will animate as the "moving" element underneath

        // Put the OLD card image on the moving-under element (the one going to bottom)
        underEl.src = oldUrl;

        // 4) Move that old card back left, but UNDER
        void underEl.offsetWidth;
        underEl.classList.add("to-left-under");
        await waitTransition(underEl);

        // 5) Slide it back to center under the deck
        underEl.classList.remove("to-left-under");
        void underEl.offsetWidth;
        underEl.classList.add("back-to-center-under");
        await waitTransition(underEl);

        // Cleanup: make sure under is calm/ready for next time
        underEl.className = "card under";
        topEl.className = "card top";

        animating = false;

        // If something was queued while animating, run it now
        if (queuedUrl) {
          const u = queuedUrl;
          queuedUrl = "";
          animateTo(u);
        }
      }

      // Now just listen + render
      onSnapshot(roomRef, (snap) => {
        if (!snap.exists()) return;

        const data = snap.data();

        const deck = Array.isArray(data.deck) ? data.deck : [];
        const order = Array.isArray(data.order) ? data.order : [];
        const idx = typeof data.idx === "number" ? data.idx : 0;

        if (!deckUrls.length || !order.length) return;

        const deckIndex = order[idx] ?? 0;
        const url = deckUrls[deckIndex];

        if (!currentUrl) setInstant(url);
        else animateTo(url);
      });
    </script>
  </body>
</html>
