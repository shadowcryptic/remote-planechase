<!doctype html>
<html>

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Planechase Display</title>

    <style>
        html,
        body {
            margin: 0;
            width: 100%;
            height: 100%;
            background: #000;
            overflow: hidden;
        }

        body {
            display: grid;
            place-items: center;
        }

        .deck {
            width: 680px;
            height: 488px;
            position: relative;
        }

        .card {
            position: absolute;
            top: 50%;
            left: 50%;

            /* centered + rotated base */
            transform: translate(-50%, -50%) rotate(90deg);

            /* shrink-only (rotated => swap limits) */
            max-width: 488px;
            max-height: 680px;
            width: auto;
            height: auto;
            object-fit: contain;

            border-radius: 14px;
            box-shadow: 0 18px 50px rgba(0, 0, 0, 0.55);
            user-select: none;
            -webkit-user-drag: none;
            will-change: transform;
        }

        /* resting roles */
        .top {
            z-index: 2;
            transform: translate(-50%, -50%) rotate(90deg) translateX(0) translateZ(0);
        }

        .under {
            z-index: 1;
            transform: translate(-50%, -50%) rotate(90deg) translateX(0) translateZ(0px);
        }

        /* ---------- NEXT animation ---------- */
        /* top slides out right (reveals under) */
        .top.to-right {
            transition: transform 760ms cubic-bezier(0.2, 0.8, 0.2, 1);
            transform: translate(-50%, -50%) rotate(90deg) translateX(500px) translateZ(0);
        }

        /* old top becomes under, parked at-right-under instantly */
        .under.park-right {
            transition: none !important;
            transform: translate(-50%, -50%) rotate(90deg) translateX(500px) translateZ(0px);
        }

        /* old top returns to center underneath */
        .under.return-center {
            transition: transform 1320ms cubic-bezier(0.2, 0.8, 0.2, 1);
            transform: translate(-50%, -50%) rotate(90deg) translateX(0) translateZ(0px);
        }

        /* ---------- PREV animation ---------- */
        /* under slides out right while staying under */
        .under.under-to-right {
            transition: transform 760ms cubic-bezier(0.2, 0.8, 0.2, 1);
            transform: translate(-50%, -50%) rotate(90deg) translateX(500px) translateZ(0px);
        }

        /* promote under to top at-right instantly */
        .top.park-right-top {
            transition: none !important;
            z-index: 3;
            transform: translate(-50%, -50%) rotate(90deg) translateX(500px) translateZ(0);
        }

        /* return on top to center */
        .top.return-center-top {
            transition: transform 820ms cubic-bezier(0.2, 0.8, 0.2, 1);
            z-index: 3;
            transform: translate(-50%, -50%) rotate(90deg) translateX(0) translateZ(0);
        }

        /* Optional debug overlay */
        #status {
            position: fixed;
            left: 12px;
            top: 12px;
            z-index: 9999;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
                "Liberation Mono", "Courier New", monospace;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.8);
            background: rgba(0, 0, 0, 0.35);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 10px;
            padding: 8px 10px;
        }

        /* If you have Reduce Motion enabled, animations will not run. */
        @media (prefers-reduced-motion: reduce) {

            .top.to-right,
            .under.return-center,
            .under.under-to-right,
            .top.return-center-top {
                transition: none !important;
            }
        }
    </style>
</head>

<body>
    <div id="status">Bootingâ€¦</div>

    <div class="deck">
        <img id="cardUnder" class="card under" alt="" />
        <img id="cardTop" class="card top" alt="" />
    </div>

    <script type="module">
        import { db, doc, onSnapshot, runTransaction, serverTimestamp } from "./common.js";

        const statusEl = document.getElementById("status");
        const roomRef = doc(db, "rooms", "my-room");

        const topImg = document.getElementById("cardTop");
        const underImg = document.getElementById("cardUnder");
        let topEl = document.getElementById("cardTop");
        let underEl = document.getElementById("cardUnder");
        const BACK_URL = "https://backs.scryfall.io/large/7/8/7840c131-f96b-4700-9347-2215c43156e6.jpg";

        let deckUrls = [];
        let currentUrl = "";
        let animating = false;
        let lastIdx = null;
        let lastResetAt = null;
        let revealedOnce = false;
        setInstant(BACK_URL);

        function setStatus(text) {
            statusEl.textContent = text;
        }

        function normalize() {
            topEl.className = "card top";
            underEl.className = "card under";
        }

        // Optional but helps avoid visual glitches on slower loads:
        async function setSrcAndDecode(img, url) {
            img.src = url;
            if (img.decode) {
                try { await img.decode(); } catch (_) { }
            }
        }

        async function loadDeck() {
            const res = await fetch("./deck.json", { cache: "no-store" });
            if (!res.ok) throw new Error("Failed to load deck.json");
            const data = await res.json();
            return Array.isArray(data.deck) ? data.deck : [];
        }

        function shuffledIndices(n) {
            const a = [];
            for (let i = 0; i < n; i++) a.push(i);
            for (let i = n - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                const tmp = a[i];
                a[i] = a[j];
                a[j] = tmp;
            }
            return a;
        }

        function parseTimeListToMs(listStr) {
            // "0.32s, 120ms" -> [320,120]
            const parts = listStr.split(",").map((s) => s.trim());
            const ms = parts.map((p) => {
                if (p.endsWith("ms")) return Number(p.slice(0, -2));
                if (p.endsWith("s")) return Number(p.slice(0, -1)) * 1000;
                return Number(p) || 0;
            });
            return ms;
        }


        function waitTransition(el) {
            return new Promise((resolve) => {
                const onEnd = (e) => {
                    if (e.target !== el) return;
                    if (e.propertyName !== "transform") return;
                    el.removeEventListener("transitionend", onEnd);
                    resolve();
                };
                el.addEventListener("transitionend", onEnd);

                // fallback in case transitionend doesn't fire
                setTimeout(() => {
                    el.removeEventListener("transitionend", onEnd);
                    resolve();
                }, 2000);
            });
        }

        function resetClasses() {
            topImg.className = "card top";
            underImg.className = "card under";
        }

        function setInstant(url) {
            topImg.src = url;
            underImg.src = url;
            currentUrl = url;
            resetClasses();
        }

        async function animateNext(nextUrl) {
            const oldUrl = currentUrl;
            currentUrl = nextUrl;

            // Put next card underneath and make sure it's ready BEFORE revealing
            await setSrcAndDecode(underEl, nextUrl);

            // Slide old top out to the right
            normalize();
            void topEl.offsetWidth;
            topEl.classList.add("to-right");
            await waitTransition(topEl);

            // Swap element references so the NEW card becomes the permanent top element.
            // This avoids any end-of-animation src swapping flick.
            const oldTop = topEl;
            topEl = underEl;
            underEl = oldTop;

            // New top stays centered and never moves
            topEl.className = "card top";

            // Old card becomes under, parked at right-under, then returns under to center
            underEl.className = "card under park-right";
            underEl.src = oldUrl;

            void underEl.offsetWidth;
            underEl.classList.remove("park-right");
            underEl.classList.add("return-center");
            await waitTransition(underEl);

            // Resting state
            underEl.className = "card under";
        }

        async function animatePrev(prevUrl) {
            const oldUrl = currentUrl;
            currentUrl = prevUrl;

            // Under card will become the new top; prepare it first
            await setSrcAndDecode(underEl, prevUrl);

            // Top MUST NOT MOVE. Only under animates.
            normalize();

            // Under slides out to the right (still underneath)
            void underEl.offsetWidth;
            underEl.classList.add("under-to-right");
            await waitTransition(underEl);

            // Promote under to top at-right instantly, then return to center on top
            underEl.className = "card top park-right-top";
            void underEl.offsetWidth;

            underEl.classList.remove("park-right-top");
            underEl.classList.add("return-center-top");
            await waitTransition(underEl);

            // Swap references AFTER the under finished becoming top.
            // Now the new top is permanently topEl, and the old top becomes under.
            const oldTop = topEl;
            topEl = underEl;
            underEl = oldTop;

            topEl.className = "card top";

            underEl.className = "card under";
            underEl.src = oldUrl;
        }

        async function animateTo(url, delta) {
            if (!url || url === currentUrl || animating) return;
            animating = true;
            try {
                if (delta > 0) await animateNext(url);
                else await animatePrev(url);
            } finally {
                animating = false;
            }
        }


        // Load deck
        deckUrls = await loadDeck();
        setStatus("Deck loaded: " + deckUrls.length);

        // Ensure order exists and matches deck length
        await runTransaction(db, async (tx) => {
            const snap = await tx.get(roomRef);
            const existing = snap.exists() ? snap.data() : {};
            const order = Array.isArray(existing.order) ? existing.order : [];

            if (deckUrls.length > 0 && order.length !== deckUrls.length) {
                tx.set(
                    roomRef,
                    {
                        order: shuffledIndices(deckUrls.length),
                        idx: 0,
                        shuffledAt: serverTimestamp(),
                    },
                    { merge: true },
                );
            }
        });

        // Listen for idx changes
        onSnapshot(roomRef, (snap) => {
            if (!snap.exists()) return;

            const data = snap.data();
            const order = Array.isArray(data.order) ? data.order : [];
            const idx = typeof data.idx === "number" ? data.idx : 0;
            const resetAt = data.resetAt ?? null;

            if (!deckUrls.length || !order.length) return;

            const deckIndex = order[idx] ?? 0;
            const url = deckUrls[deckIndex];

            // ðŸ”´ HARD RESET DETECTED
            if (resetAt && resetAt !== lastResetAt) {
                lastResetAt = resetAt;

                // Reset local state
                revealedOnce = false;
                lastIdx = idx;
                currentUrl = BACK_URL;

                // Immediately show card back
                setInstant(BACK_URL);
                return;
            }

            // ðŸŸ¢ FIRST REVEAL (after reset or page load)
            if (!revealedOnce) {
                revealedOnce = true;
                lastIdx = idx;
                animateTo(url, 1); // NEXT-style reveal
                return;
            }

            // ðŸŸ¡ NORMAL NAVIGATION
            const deltaRaw = idx - (lastIdx ?? idx);
            lastIdx = idx;

            if (Math.abs(deltaRaw) !== 1) {
                setInstant(url);
                return;
            }

            animateTo(url, deltaRaw > 0 ? 1 : -1);
        });

    </script>
</body>

</html>