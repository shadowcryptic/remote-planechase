<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Display Debug</title>
    <style>
      html,
      body {
        margin: 0;
        width: 100%;
        height: 100%;
        background: #000;
        overflow: hidden;
      }
      body {
        display: grid;
        place-items: center;
      }

      /* Deck viewport: fixed target size */
      .deck {
        width: 680px;
        height: 488px;
        position: relative;
        perspective: 1200px;
      }

      .card {
        position: absolute;
        inset: 0;
        margin: auto;

        /* Centered */
        display: block;

        /* Rotation (clockwise) */
        transform-origin: center;

        /* shrink-only (rotated => swap limits) */
        max-width: 488px;
        max-height: 680px;
        width: auto;
        height: auto;
        object-fit: contain;

        /* Visual polish */
        border-radius: 14px;
        box-shadow: 0 18px 50px rgba(0, 0, 0, 0.55);
        will-change: transform, opacity;
        user-select: none;
        -webkit-user-drag: none;

        /* Default: sitting as the deck */
        transform: rotate(90deg) translateZ(0);
        opacity: 1;
      }

      /* The current visible top card */
      .top {
        z-index: 2;
      }

      /* The card underneath (slightly offset for deck feel) */
      .under {
        z-index: 1;
        transform: rotate(90deg) translateY(6px) translateZ(-12px);
        opacity: 1;
      }

      /* Animation: top card goes "behind" (down + away + slight shrink) */
      .send-behind {
        transition:
          transform 320ms cubic-bezier(0.2, 0.8, 0.2, 1),
          opacity 320ms ease;
        transform: rotate(90deg) translateY(40px) translateZ(-120px) scale(0.96);
        opacity: 0.98;
      }

      /* Reduced motion accessibility */
      @media (prefers-reduced-motion: reduce) {
        .send-behind {
          transition: none;
        }
      }
    </style>
  </head>
  <body>
    <div id="status">Bootingâ€¦</div>
    <pre id="dump"></pre>
    <div class="deck">
      <img id="cardA" class="card top" alt="" />
      <img id="cardB" class="card" alt="" />
    </div>

    <script type="module">
      import {
        db,
        doc,
        onSnapshot,
        setDoc,
        runTransaction,
        serverTimestamp,
      } from "./common.js";

      const roomRef = doc(db, "rooms", "my-room");

      async function loadDeck() {
        const res = await fetch("./deck.json", { cache: "no-store" });
        if (!res.ok) throw new Error("Failed to load deck.json");
        const data = await res.json();
        return Array.isArray(data.deck) ? data.deck : [];
      }

      function shuffledIndices(n) {
        const a = [];
        for (let i = 0; i < n; i++) a.push(i);
        for (let i = n - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          const tmp = a[i];
          a[i] = a[j];
          a[j] = tmp;
        }
        return a;
      }

      const a = document.getElementById("cardA");
      const b = document.getElementById("cardB");

      let topEl = a;
      let underEl = b;
      let currentUrl = "";

      // Initialize layer classes
      topEl.classList.add("top");
      underEl.classList.add("under");

      function setTopInstant(url) {
        topEl.src = url;
        underEl.src = url; // keep it consistent at start
        currentUrl = url;
      }

      function animateTo(url) {
        if (!url || url === currentUrl) return;

        // Put the new card underneath first
        underEl.src = url;

        // Force layout so class changes animate reliably
        void topEl.offsetWidth;

        // Animate current top "behind"
        topEl.classList.add("send-behind");

        // After animation, swap roles (new becomes top)
        window.setTimeout(() => {
          // Clean up old top styles
          topEl.classList.remove("top", "send-behind");
          topEl.classList.add("under");

          // Promote under to top
          underEl.classList.remove("under");
          underEl.classList.add("top");

          // Swap references
          const tmp = topEl;
          topEl = underEl;
          underEl = tmp;

          currentUrl = url;
        }, 330);
      }

      const deckUrls = await loadDeck();

      // Ensure Firestore has an order matching deck length (runtime shuffle)
      await runTransaction(db, async (tx) => {
        const snap = await tx.get(roomRef);
        const existing = snap.exists() ? snap.data() : {};
        const order = Array.isArray(existing.order) ? existing.order : [];

        if (order.length !== deckUrls.length) {
          tx.set(
            roomRef,
            {
              order: shuffledIndices(deckUrls.length),
              idx: 0,
              shuffledAt: serverTimestamp(),
            },
            { merge: true },
          );
        }
      });

      // Now just listen + render
      onSnapshot(roomRef, (snap) => {
        if (!snap.exists()) return;

        const data = snap.data();

        const deck = Array.isArray(data.deck) ? data.deck : [];
        const order = Array.isArray(data.order) ? data.order : [];
        const idx = typeof data.idx === "number" ? data.idx : 0;

        if (!deckUrls.length || !order.length) return;

        const deckIndex = order[idx] ?? 0;
        const url = deckUrls[deckIndex];


        // ðŸ”‘ HERE IS THE IMPORTANT PART
        if (!currentUrl) {
          // First card ever shown (page load)
          setTopInstant(url);
        } else {
          // Every subsequent change (Next / Prev)
          animateTo(url);
        }
      });

      
    </script>
  </body>
</html>
