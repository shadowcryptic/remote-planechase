<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Planechase Display</title>

    <style>
      html,
      body {
        margin: 0;
        width: 100%;
        height: 100%;
        background: #000;
        overflow: hidden;
      }
      body {
        display: grid;
        place-items: center;
      }

      .deck {
        width: 680px;
        height: 488px;
        position: relative;
      }

      .card {
        position: absolute;
        top: 50%;
        left: 50%;

        /* centered + rotated base */
        transform: translate(-50%, -50%) rotate(90deg);

        /* shrink-only (rotated => swap limits) */
        max-width: 488px;
        max-height: 680px;
        width: auto;
        height: auto;
        object-fit: contain;

        border-radius: 14px;
        box-shadow: 0 18px 50px rgba(0, 0, 0, 0.55);
        user-select: none;
        -webkit-user-drag: none;
        will-change: transform;
      }

      /* resting roles */
      .top {
        z-index: 2;
        transform: translate(-50%, -50%) rotate(90deg) translateX(0) translateZ(0);
      }

      .under {
        z-index: 1;
        transform: translate(-50%, -50%) rotate(90deg) translateX(0) translateZ(0px);
      }

      /* ---------- NEXT animation ---------- */
      /* top slides out right (reveals under) */
      .top.to-right {
        transition: transform 760ms cubic-bezier(0.2, 0.8, 0.2, 1);
        transform: translate(-50%, -50%) rotate(90deg) translateX(500px) translateZ(0);
      }

      /* old top becomes under, parked at-right-under instantly */
      .under.park-right {
        transition: none !important;
        transform: translate(-50%, -50%) rotate(90deg) translateX(500px) translateZ(0px);
      }

      /* old top returns to center underneath */
      .under.return-center {
        transition: transform 1820ms cubic-bezier(0.2, 0.8, 0.2, 1);
        transform: translate(-50%, -50%) rotate(90deg) translateX(0) translateZ(0px);
      }

      /* ---------- PREV animation ---------- */
      /* under slides out right while staying under */
      .under.under-to-right {
        transition: transform 760ms cubic-bezier(0.2, 0.8, 0.2, 1);
        transform: translate(-50%, -50%) rotate(90deg) translateX(500px) translateZ(0px);
      }

      /* promote under to top at-right instantly */
      .top.park-right-top {
        transition: none !important;
        z-index: 3;
        transform: translate(-50%, -50%) rotate(90deg) translateX(500px) translateZ(0);
      }

      /* return on top to center */
      .top.return-center-top {
        transition: transform 820ms cubic-bezier(0.2, 0.8, 0.2, 1);
        z-index: 3;
        transform: translate(-50%, -50%) rotate(90deg) translateX(0) translateZ(0);
      }

      /* Optional debug overlay */
      #status {
        position: fixed;
        left: 12px;
        top: 12px;
        z-index: 9999;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
        font-size: 12px;
        color: rgba(255, 255, 255, 0.8);
        background: rgba(0, 0, 0, 0.35);
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 10px;
        padding: 8px 10px;
      }

      /* If you have Reduce Motion enabled, animations will not run. */
      @media (prefers-reduced-motion: reduce) {
        .top.to-right,
        .under.return-center,
        .under.under-to-right,
        .top.return-center-top {
          transition: none !important;
        }
      }
    </style>
  </head>

  <body>
    <div id="status">Bootingâ€¦</div>

    <div class="deck">
      <img id="cardUnder" class="card under" alt="" />
      <img id="cardTop" class="card top" alt="" />
    </div>

    <script type="module">
      import { db, doc, onSnapshot, runTransaction, serverTimestamp } from "./common.js";

      const statusEl = document.getElementById("status");
      const roomRef = doc(db, "rooms", "my-room");

      const topImg = document.getElementById("cardTop");
      const underImg = document.getElementById("cardUnder");

      let deckUrls = [];
      let currentUrl = "";
      let animating = false;
      let lastIdx = null;

      function setStatus(text) {
        statusEl.textContent = text;
      }

      async function loadDeck() {
        const res = await fetch("./deck.json", { cache: "no-store" });
        if (!res.ok) throw new Error("Failed to load deck.json");
        const data = await res.json();
        return Array.isArray(data.deck) ? data.deck : [];
      }

      function shuffledIndices(n) {
        const a = [];
        for (let i = 0; i < n; i++) a.push(i);
        for (let i = n - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          const tmp = a[i];
          a[i] = a[j];
          a[j] = tmp;
        }
        return a;
      }

function parseTimeListToMs(listStr) {
  // "0.32s, 120ms" -> [320,120]
  const parts = listStr.split(",").map((s) => s.trim());
  const ms = parts.map((p) => {
    if (p.endsWith("ms")) return Number(p.slice(0, -2));
    if (p.endsWith("s")) return Number(p.slice(0, -1)) * 1000;
    return Number(p) || 0;
  });
  return ms;
}

function waitTransition(el) {
  return new Promise((resolve) => {
    const cs = getComputedStyle(el);

    const durations = parseTimeListToMs(cs.transitionDuration);
    const delays = parseTimeListToMs(cs.transitionDelay);

    // If multiple transitions are defined, the browser pairs them by index.
    // Use the max (duration+delay) as the true upper bound.
    const n = Math.max(durations.length, delays.length, 1);
    let maxTotal = 0;
    for (let i = 0; i < n; i++) {
      const d = durations[i] ?? durations[durations.length - 1] ?? 0;
      const l = delays[i] ?? delays[delays.length - 1] ?? 0;
      const total = d + l;
      if (total > maxTotal) maxTotal = total;
    }

    // If transitions are effectively off, resolve next tick.
    if (maxTotal <= 0) {
      requestAnimationFrame(() => resolve());
      return;
    }

    let done = false;

    const onEnd = (e) => {
      if (done) return;
      if (e.target !== el) return;
      if (e.propertyName !== "transform") return;
      done = true;
      el.removeEventListener("transitionend", onEnd);
      clearTimeout(timer);
      resolve();
    };

    el.addEventListener("transitionend", onEnd);

    // Safety timeout slightly above actual max duration
    const timer = setTimeout(() => {
      if (done) return;
      done = true;
      el.removeEventListener("transitionend", onEnd);
      resolve();
    }, maxTotal + 80);
  });
}

      function resetClasses() {
        topImg.className = "card top";
        underImg.className = "card under";
      }

      function setInstant(url) {
        topImg.src = url;
        underImg.src = url;
        currentUrl = url;
        resetClasses();
      }

      async function animateNext(nextUrl) {
        // NEXT: current top moves right; new top never moves
        const oldUrl = currentUrl;
        currentUrl = nextUrl;

        resetClasses();
        underImg.src = nextUrl;

        // move top out
        void topImg.offsetWidth;
        topImg.classList.add("to-right");
        await waitTransition(topImg);

        // old card becomes under, parked at-right-under
        topImg.className = "card under park-right";
        topImg.src = oldUrl;

        // new top should be stable and never move
        underImg.className = "card top";

        // return old under to center
        void topImg.offsetWidth;
        topImg.classList.remove("park-right");
        topImg.classList.add("return-center");
        await waitTransition(topImg);

        // Restore fixed roles by swapping src (prevents flick)
        resetClasses();
        topImg.src = nextUrl;
        underImg.src = oldUrl;
      }

      async function animatePrev(prevUrl) {
        // PREV: current top does not move; only the under card comes onto top
        const oldUrl = currentUrl;
        currentUrl = prevUrl;

        resetClasses();
        underImg.src = prevUrl;

        // under slides out to right (still under)
        void underImg.offsetWidth;
        underImg.classList.add("under-to-right");
        await waitTransition(underImg);

        // promote to top at-right instantly...
        underImg.className = "card top park-right-top";
        void underImg.offsetWidth;

        // ...then return to center on top
        underImg.classList.remove("park-right-top");
        underImg.classList.add("return-center-top");
        await waitTransition(underImg);

        // Commit final state (top is prevUrl, under is oldUrl)
        resetClasses();
        topImg.src = prevUrl;
        underImg.src = oldUrl;
      }

      async function animateTo(url, delta) {
        if (!url || url === currentUrl || animating) return;
        animating = true;
        try {
          if (delta > 0) await animateNext(url);
          else await animatePrev(url);
        } finally {
          animating = false;
        }
      }

      // Load deck
      deckUrls = await loadDeck();
      setStatus("Deck loaded: " + deckUrls.length);

      // Ensure order exists and matches deck length
      await runTransaction(db, async (tx) => {
        const snap = await tx.get(roomRef);
        const existing = snap.exists() ? snap.data() : {};
        const order = Array.isArray(existing.order) ? existing.order : [];

        if (deckUrls.length > 0 && order.length !== deckUrls.length) {
          tx.set(
            roomRef,
            {
              order: shuffledIndices(deckUrls.length),
              idx: 0,
              shuffledAt: serverTimestamp(),
            },
            { merge: true },
          );
        }
      });

      // Listen for idx changes
      onSnapshot(
        roomRef,
        (snap) => {
          if (!snap.exists()) {
            setStatus("Room doc not found");
            return;
          }

          const data = snap.data();
          const order = Array.isArray(data.order) ? data.order : [];
          const idx = typeof data.idx === "number" ? data.idx : 0;

          if (!deckUrls.length || !order.length) return;

          const deckIndex = order[idx] ?? 0;
          const url = deckUrls[deckIndex];

          setStatus("idx " + idx + " / " + order.length);

          if (!currentUrl) {
            setInstant(url);
            lastIdx = idx;
            return;
          }

          const deltaRaw = idx - (lastIdx ?? idx);
          lastIdx = idx;

          // Big jumps: snap (no animation)
          if (Math.abs(deltaRaw) !== 1) {
            setInstant(url);
            return;
          }

          animateTo(url, deltaRaw > 0 ? 1 : -1);
        },
        (err) => {
          setStatus("Snapshot error: " + err.message);
        },
      );
    </script>
  </body>
</html>
