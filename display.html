<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Planechase Display</title>

    <style>
      html,
      body {
        margin: 0;
        width: 100%;
        height: 100%;
        background: #000;
        overflow: hidden;
      }
      body {
        display: grid;
        place-items: center;
      }

      .deck {
        width: 680px;
        height: 488px;
        position: relative;
      }

      /* Base card styling + perfect centering */
      .card {
        position: absolute;
        top: 50%;
        left: 50%;

        /* base transform = centered + rotated */
        transform: translate(-50%, -50%) rotate(90deg);

        /* shrink-only (rotated => swap limits) */
        max-width: 488px;
        max-height: 680px;
        width: auto;
        height: auto;
        object-fit: contain;

        border-radius: 14px;
        box-shadow: 0 18px 50px rgba(0, 0, 0, 0.55);
        user-select: none;
        -webkit-user-drag: none;
        will-change: transform;
      }

      /* Roles */
      .top {
        z-index: 2;
        transform: translate(-50%, -50%) rotate(90deg) translateX(0) translateZ(0);
      }
      .under {
        z-index: 1;
        transform: translate(-50%, -50%) rotate(90deg) translateX(0) translateZ(0px)
          /* scale(0.96); */
      }

      /* Shared: top slides to the right to reveal what's underneath */
      .top.to-right {
        transition: transform 760ms cubic-bezier(0.2, 0.8, 0.2, 1);
        transform: translate(-50%, -50%) rotate(90deg) translateX(488px) translateZ(0);
      }

      /* NEXT: old top becomes under, stays parked at-right-under (no transition) */
      .under.park-right {
        transition: none !important;
        transform: translate(-50%, -50%) rotate(90deg) translateX(488px) translateZ(0px)
          /* scale(0.96); */
      }

      /* NEXT: old top returns from right -> center under */
      .under.return-center {
        transition: transform 820ms cubic-bezier(0.2, 0.8, 0.2, 1);
        transform: translate(-50%, -50%) rotate(90deg) translateX(0) translateZ(0px)
          /* scale(0.96); */
      }

      /* PREV: the under card (which will become top) moves center-under -> right-under */
      .under.under-to-right {
        transition: transform 760ms cubic-bezier(0.2, 0.8, 0.2, 1);
        transform: translate(-50%, -50%) rotate(90deg) translateX(488px) translateZ(0px)
          /* scale(0.96); */
      }

      /* PREV: promote to top at-right instantly */
      .top.park-right-top {
        transition: none !important;
        transform: translate(-50%, -50%) rotate(90deg) translateX(488px) translateZ(0);
      }

      /* PREV: new top returns right -> center on top */
      .top.return-center-top {
        transition: transform 820ms cubic-bezier(0.2, 0.8, 0.2, 1);
        transform: translate(-50%, -50%) rotate(90deg) translateX(0) translateZ(0);
      }

      /* Debug overlay (optional) */
      #status {
        position: fixed;
        left: 12px;
        top: 12px;
        z-index: 9999;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
        font-size: 12px;
        color: rgba(255, 255, 255, 0.8);
        background: rgba(0, 0, 0, 0.35);
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 10px;
        padding: 8px 10px;
      }

      @media (prefers-reduced-motion: reduce) {
        .top.to-right,
        .under.return-center,
        .under.under-to-right,
        .top.return-center-top {
          transition: none !important;
        }
      }
    </style>
  </head>

  <body>
    <div id="status">Booting…</div>

    <div class="deck">
      <img id="cardUnder" class="card under" alt="" />
      <img id="cardTop" class="card top" alt="" />
    </div>

    <script type="module">
      import { db, doc, onSnapshot, runTransaction, serverTimestamp } from "./common.js";

      const statusEl = document.getElementById("status");

      const roomRef = doc(db, "rooms", "my-room");

      async function loadDeck() {
        const res = await fetch("./deck.json", { cache: "no-store" });
        if (!res.ok) throw new Error("Failed to load deck.json");
        const data = await res.json();
        return Array.isArray(data.deck) ? data.deck : [];
      }

      function shuffledIndices(n) {
        const a = [];
        for (let i = 0; i < n; i++) a.push(i);
        for (let i = n - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          const tmp = a[i];
          a[i] = a[j];
          a[j] = tmp;
        }
        return a;
      }

      function waitTransition(el) {
        return new Promise((resolve) => {
          const onEnd = (e) => {
            if (e.propertyName !== "transform") return;
            el.removeEventListener("transitionend", onEnd);
            resolve();
          };
          el.addEventListener("transitionend", onEnd);
        });
      }

      let topEl = document.getElementById("cardTop");
      let underEl = document.getElementById("cardUnder");

      let deckUrls = [];
      let currentUrl = "";
      let animating = false;
      let lastIdx = null;

      function setInstant(url) {
        topEl.src = url;
        underEl.src = url;
        currentUrl = url;
      }

async function animateTo(nextUrl, delta) {
  if (!nextUrl || nextUrl === currentUrl || animating) return;
  animating = true;

  // Ensure clean state
  topEl.className = "card top";
  underEl.className = "card under";

  const oldUrl = currentUrl;
  currentUrl = nextUrl;

  if (delta > 0) {
    // ======================
    // NEXT: top goes to bottom
    // ======================

    // Under holds the next card
    underEl.src = nextUrl;

    // Move current top to the right (reveals under)
    void topEl.offsetWidth;
    topEl.classList.add("to-right");
    await waitTransition(topEl);

    // Swap: under becomes new top, old top becomes under
    const oldTop = topEl;
    topEl = underEl;
    underEl = oldTop;

    topEl.className = "card top";
    underEl.className = "card under";
    underEl.src = oldUrl;

    // Old card is currently at-right (because it just moved); convert to right-under, then return to center-under
    underEl.classList.add("park-right");
    void underEl.offsetWidth;

    underEl.classList.remove("park-right");
    underEl.classList.add("return-center");
    await waitTransition(underEl);

    underEl.className = "card under";
    topEl.className = "card top";
  } else {
    // ==========================================
    // PREV: top stays still, previous comes on top
    // ==========================================

    // The "previous" card starts under the deck (already centered-under),
    // then slides out to the right underneath…
    underEl.src = nextUrl;

    void underEl.offsetWidth;
    underEl.classList.add("under-to-right");
    await waitTransition(underEl);

    // …then it becomes the top card and slides back to center ON TOP.
    const oldTop = topEl;
    topEl = underEl;
    underEl = oldTop;

    // New top is currently at-right-under; promote to top at-right instantly…
    topEl.className = "card top park-right-top";
    void topEl.offsetWidth;

    // …then animate back to center on top
    topEl.classList.remove("park-right-top");
    topEl.classList.add("return-center-top");
    await waitTransition(topEl);

    topEl.className = "card top";

    // Old top becomes the under card (no animation, just demoted)
    underEl.className = "card under";
    underEl.src = oldUrl;
  }

  animating = false;
}


      // Load deck from repo
      deckUrls = await loadDeck();
      statusEl.textContent = "Deck loaded: " + deckUrls.length;

      // Ensure Firestore order exists and matches deck length
      await runTransaction(db, async (tx) => {
        const snap = await tx.get(roomRef);
        const existing = snap.exists() ? snap.data() : {};
        const order = Array.isArray(existing.order) ? existing.order : [];

        if (order.length !== deckUrls.length && deckUrls.length > 0) {
          tx.set(
            roomRef,
            {
              order: shuffledIndices(deckUrls.length),
              idx: 0,
              shuffledAt: serverTimestamp(),
            },
            { merge: true },
          );
        }
      });

      // Listen for idx/order changes
      onSnapshot(
        roomRef,
        (snap) => {
          if (!snap.exists()) {
            statusEl.textContent = "Room doc not found";
            return;
          }

          const data = snap.data();
          const order = Array.isArray(data.order) ? data.order : [];
          const idx = typeof data.idx === "number" ? data.idx : 0;

          if (!deckUrls.length || !order.length) return;

          const deckIndex = order[idx] ?? 0;
          const url = deckUrls[deckIndex];

          statusEl.textContent = "idx " + idx + " / " + order.length;

          if (!currentUrl) {
            setInstant(url);
            lastIdx = idx;
            return;
          }

          // If jump is big (reset), just snap (no animation)
          const deltaRaw = idx - (lastIdx ?? idx);
          lastIdx = idx;

          if (Math.abs(deltaRaw) !== 1) {
            setInstant(url);
            return;
          }

          animateTo(url, deltaRaw > 0 ? 1 : -1);
        },
        (err) => {
          statusEl.textContent = "Snapshot error: " + err.message;
        },
      );
    </script>
  </body>
</html>
