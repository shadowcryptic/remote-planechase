<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Display Debug</title>
    <style>
      html,
      body {
        margin: 0;
        width: 100%;
        height: 100%;
        background: #000;
        overflow: hidden;
      }
      body {
        display: grid;
        place-items: center;
      }

      .deck {
        width: 680px;
        height: 488px;
        position: relative;
      }

.card{
  position: absolute;
  top: 50%;
  left: 50%;

  /* TRUE visual centering */
  transform: translate(-50%, -50%) rotate(90deg);

  /* shrink-only (rotated => swap limits) */
  max-width: 488px;
  max-height: 680px;
  width: auto;
  height: auto;
  object-fit: contain;

  border-radius: 14px;
  box-shadow: 0 18px 50px rgba(0,0,0,0.55);
  user-select: none;
  -webkit-user-drag: none;
  will-change: transform;
}


.top{
  z-index: 2;
  transform: translate(-50%, -50%) rotate(90deg) translateX(0);
}

.top.to-right{
  transition: transform 1000ms cubic-bezier(.2,.8,.2,1);
  transform: translate(-50%, -50%) rotate(90deg) translateX(500px);
}

.top.to-left-under{
  z-index: 1;
  transition: transform 1000ms cubic-bezier(.2,.8,.2,1);
  transform: translate(-50%, -50%) rotate(90deg) translateX(-740px) translateZ(-120px) scale(0.96);
}

.top.back-to-center-under{
  z-index: 1;
  transition: transform 1000ms cubic-bezier(.2,.8,.2,1);
  transform: translate(-50%, -50%) rotate(90deg) translateX(0) translateZ(-120px) scale(0.96);
}

/* Old top card, now underneath, parked off to the right (no transition) */
.under.park-right {
  transition: none !important;
  z-index: 1;
  transform: translate(-50%, -50%) rotate(90deg) translateX(740px) translateZ(-120px) scale(0.96);
}

/* Then animate it back to center underneath */
.under.return-center {
  transition: transform 320ms cubic-bezier(.2,.8,.2,1);
  z-index: 1;
  transform: translate(-50%, -50%) rotate(90deg) translateX(0) translateZ(-120px) scale(0.96);
}


.under{
  z-index: 1;
  transform: translate(-50%, -50%) rotate(90deg);
}

#status, #dump {
  position: fixed;
  left: 12px;
  z-index: 9999;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size: 12px;
  color: rgba(255,255,255,0.75);
  background: rgba(0,0,0,0.35);
  border: 1px solid rgba(255,255,255,0.12);
  border-radius: 10px;
  padding: 8px 10px;
  max-width: min(520px, calc(100vw - 24px));
}

#status {
  top: 12px;
}

#dump {
  top: 52px;
  max-height: 40vh;
  overflow: auto;
  white-space: pre-wrap;
  word-break: break-word;
}


      @media (prefers-reduced-motion: reduce) {
        .top.to-right,
        /* .top.to-left-under, */
        .top.back-to-center-under {
          transition: none;
        }
      }
    </style>
  </head>
  <body>
    <div id="status">Booting…</div>
    <pre id="dump"></pre>
    <div class="deck">
      <img id="cardUnder" class="card under" alt="" />
      <img id="cardTop" class="card top" alt="" />
    </div>

    <script type="module">
      import {
        db,
        doc,
        onSnapshot,
        setDoc,
        runTransaction,
        serverTimestamp,
      } from "./common.js";

      const roomRef = doc(db, "rooms", "my-room");

      async function loadDeck() {
        const res = await fetch("./deck.json", { cache: "no-store" });
        if (!res.ok) throw new Error("Failed to load deck.json");
        const data = await res.json();
        return Array.isArray(data.deck) ? data.deck : [];
      }

      function shuffledIndices(n) {
        const a = [];
        for (let i = 0; i < n; i++) a.push(i);
        for (let i = n - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          const tmp = a[i];
          a[i] = a[j];
          a[j] = tmp;
        }
        return a;
      }

      const deckUrls = await loadDeck();

      // Ensure Firestore has an order matching deck length (runtime shuffle)
      await runTransaction(db, async (tx) => {
        const snap = await tx.get(roomRef);
        const existing = snap.exists() ? snap.data() : {};
        const order = Array.isArray(existing.order) ? existing.order : [];

        if (order.length !== deckUrls.length) {
          tx.set(
            roomRef,
            {
              order: shuffledIndices(deckUrls.length),
              idx: 0,
              shuffledAt: serverTimestamp(),
            },
            { merge: true },
          );
        }
      });

let topEl = document.getElementById("cardTop");
let underEl = document.getElementById("cardUnder");

let currentUrl = "";
let animating = false;

function setInstant(url){
  topEl.src = url;
  underEl.src = url;
  currentUrl = url;
}

function waitTransition(el){
  return new Promise((resolve) => {
    const onEnd = (e) => {
      if (e.propertyName !== "transform") return;
      el.removeEventListener("transitionend", onEnd);
      resolve();
    };
    el.addEventListener("transitionend", onEnd);
  });
}

function nextFrame(){
  return new Promise((r) => requestAnimationFrame(() => r()));
}

async function animateTo(nextUrl){
  if (!nextUrl || nextUrl === currentUrl || animating) return;
  animating = true;

  // Put NEXT card underneath (revealed when top moves away)
  underEl.src = nextUrl;

  // 1) Slide the current top to the right
  topEl.classList.remove("to-right");
  void topEl.offsetWidth;
  topEl.classList.add("to-right");
  await waitTransition(topEl);

  // 2) "Tuck under": swap which element is the top vs under,
  // but KEEP the old card parked at the right.
  const oldUrl = currentUrl;
  currentUrl = nextUrl;

  // Swap element references so the new card becomes topEl
  const oldTopEl = topEl;
  topEl = underEl;
  underEl = oldTopEl;

  // Normalize classes
  topEl.className = "card top";        // new visible top (stays centered)
  underEl.className = "card under";    // old card will animate underneath

  // Put old image on the under element (the one that was slid right)
  underEl.src = oldUrl;

  // IMPORTANT: it is currently at-right because it just finished that animation.
  // Convert that right-position into an "under parked-right" state *without moving*:
  underEl.classList.add("park-right");
  void underEl.offsetWidth;

  // 3) Now animate it from right → center underneath
  underEl.classList.remove("park-right");
  underEl.classList.add("return-center");
  await waitTransition(underEl);

  // Cleanup for next time
  underEl.classList.remove("return-center");
  underEl.className = "card under";
  topEl.className = "card top";

  animating = false;
}

      // Now just listen + render
      onSnapshot(roomRef, (snap) => {
        if (!snap.exists()) return;

        const data = snap.data();

        const deck = Array.isArray(data.deck) ? data.deck : [];
        const order = Array.isArray(data.order) ? data.order : [];
        const idx = typeof data.idx === "number" ? data.idx : 0;

        if (!deckUrls.length || !order.length) return;

        const deckIndex = order[idx] ?? 0;
        const url = deckUrls[deckIndex];

        if (!currentUrl) setInstant(url);
        else animateTo(url);
      });
    </script>
  </body>
</html>
