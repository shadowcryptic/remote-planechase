<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Display Debug</title>
    <style>
      html,
      body {
        margin: 0;
        width: 100%;
        height: 100%;
        background: #000;
        overflow: hidden;
      }
      body {
        display: grid;
        place-items: center;
      }

      .deck {
        width: 680px;
        height: 488px;
        position: relative;
      }

.card{
  position: absolute;
  top: 50%;
  left: 50%;

  /* TRUE visual centering */
  transform: translate(-50%, -50%) rotate(90deg);

  /* shrink-only (rotated => swap limits) */
  max-width: 488px;
  max-height: 680px;
  width: auto;
  height: auto;
  object-fit: contain;

  border-radius: 14px;
  box-shadow: 0 18px 50px rgba(0,0,0,0.55);
  user-select: none;
  -webkit-user-drag: none;
  will-change: transform;
}


.top{
  z-index: 2;
  transform: translate(-50%, -50%) rotate(90deg) translateX(0);
}

/* Under card (bottom) parked at center under the deck (no transition) */
.under.park-center-under {
  transition: none !important;
  z-index: 1;
  transform: translate(-50%, -50%) rotate(90deg) translateX(0) translateZ(-120px) scale(0.96);
}

/* Under card slides from center-under -> right-under (transition) */
.under.under-to-right {
  transition: transform 260ms cubic-bezier(.2,.8,.2,1);
  z-index: 1;
  transform: translate(-50%, -50%) rotate(90deg) translateX(740px) translateZ(-120px) scale(0.96);
}

/* Promote that card to top at-right (no transition) */
.top.park-right-top {
  transition: none !important;
  z-index: 2;
  transform: translate(-50%, -50%) rotate(90deg) translateX(740px) translateZ(0);
}

/* Then slide it back to center ON TOP */
.top.return-center-top {
  transition: transform 320ms cubic-bezier(.2,.8,.2,1);
  z-index: 2;
  transform: translate(-50%, -50%) rotate(90deg) translateX(0) translateZ(0);
}



.under{
  z-index: 1;
  transform: translate(-50%, -50%) rotate(90deg);
}

#status, #dump {
  position: fixed;
  left: 12px;
  z-index: 9999;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size: 12px;
  color: rgba(255,255,255,0.75);
  background: rgba(0,0,0,0.35);
  border: 1px solid rgba(255,255,255,0.12);
  border-radius: 10px;
  padding: 8px 10px;
  max-width: min(520px, calc(100vw - 24px));
}

#status {
  top: 12px;
}

#dump {
  top: 52px;
  max-height: 40vh;
  overflow: auto;
  white-space: pre-wrap;
  word-break: break-word;
}


      @media (prefers-reduced-motion: reduce) {
        .top.to-right,
        /* .top.to-left-under, */
        .top.back-to-center-under {
          transition: none;
        }
      }
    </style>
  </head>
  <body>
    <div id="status">Bootingâ€¦</div>
    <pre id="dump"></pre>
    <div class="deck">
      <img id="cardUnder" class="card under" alt="" />
      <img id="cardTop" class="card top" alt="" />
    </div>

    <script type="module">
      import {
        db,
        doc,
        onSnapshot,
        setDoc,
        runTransaction,
        serverTimestamp,
      } from "./common.js";

      const roomRef = doc(db, "rooms", "my-room");

      async function loadDeck() {
        const res = await fetch("./deck.json", { cache: "no-store" });
        if (!res.ok) throw new Error("Failed to load deck.json");
        const data = await res.json();
        return Array.isArray(data.deck) ? data.deck : [];
      }

      function shuffledIndices(n) {
        const a = [];
        for (let i = 0; i < n; i++) a.push(i);
        for (let i = n - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          const tmp = a[i];
          a[i] = a[j];
          a[j] = tmp;
        }
        return a;
      }

      const deckUrls = await loadDeck();

      // Ensure Firestore has an order matching deck length (runtime shuffle)
      await runTransaction(db, async (tx) => {
        const snap = await tx.get(roomRef);
        const existing = snap.exists() ? snap.data() : {};
        const order = Array.isArray(existing.order) ? existing.order : [];

        if (order.length !== deckUrls.length) {
          tx.set(
            roomRef,
            {
              order: shuffledIndices(deckUrls.length),
              idx: 0,
              shuffledAt: serverTimestamp(),
            },
            { merge: true },
          );
        }
      });

let topEl = document.getElementById("cardTop");
let underEl = document.getElementById("cardUnder");

let currentUrl = "";
let animating = false;
let lastIdx = null;

function setInstant(url){
  topEl.src = url;
  underEl.src = url;
  currentUrl = url;
}

function waitTransition(el){
  return new Promise((resolve) => {
    const onEnd = (e) => {
      if (e.propertyName !== "transform") return;
      el.removeEventListener("transitionend", onEnd);
      resolve();
    };
    el.addEventListener("transitionend", onEnd);
  });
}

function nextFrame(){
  return new Promise((r) => requestAnimationFrame(() => r()));
}

async function animateTo(nextUrl, delta) {
  if (!nextUrl || nextUrl === currentUrl || animating) return;
  animating = true;

  // Under always holds the "target" card we want to reveal eventually
  underEl.src = nextUrl;

  // 1) Slide current top to the right (shared for both directions)
  topEl.classList.remove("to-right");
  void topEl.offsetWidth;
  topEl.classList.add("to-right");
  await waitTransition(topEl);

  const oldUrl = currentUrl;
  currentUrl = nextUrl;

  if (delta > 0) {
    // ===== NEXT: old top goes to bottom, returns under from right -> center =====

    // Swap: new card becomes the top (it was underEl)
    const oldTopEl = topEl;
    topEl = underEl;
    underEl = oldTopEl;

    topEl.className = "card top";
    underEl.className = "card under";

    // old card image on moving under element
    underEl.src = oldUrl;

    // lock it at right-under, then animate back to center-under
    underEl.classList.add("park-right");
    void underEl.offsetWidth;
    underEl.classList.remove("park-right");
    underEl.classList.add("return-center");
    await waitTransition(underEl);

    underEl.classList.remove("return-center");
    underEl.className = "card under";
    topEl.className = "card top";
  } else {
    // ===== PREV: card comes from bottom to top (reverse) =====
    // At this moment, topEl is at-right (after .to-right).
    // We want the previous card (nextUrl) to "come from bottom" to become top.

    // Step A: move the under card (nextUrl) from center-under -> right-under
    underEl.className = "card under park-center-under";
    void underEl.offsetWidth;
    underEl.classList.remove("park-center-under");
    underEl.classList.add("under-to-right");
    await waitTransition(underEl);

    // Step B: swap roles so underEl becomes TOP at-right,
    // and old top becomes UNDER at-right (it stays off to the right)
    const oldTopEl = topEl;    // contains oldUrl at-right
    const oldUnderEl = underEl; // contains nextUrl at-right-under

    topEl = oldUnderEl;
    underEl = oldTopEl;

    // Promote new card to top, parked at-right (no transition), then return to center on top
    topEl.className = "card top park-right-top";
    void topEl.offsetWidth;
    topEl.classList.remove("park-right-top");
    topEl.classList.add("return-center-top");
    await waitTransition(topEl);

    topEl.classList.remove("return-center-top");
    topEl.className = "card top";

    // The old card should end up as the under card centered-under (bottom)
    underEl.className = "card under";
    underEl.src = oldUrl; // keep old card underneath ready for future moves
  }

  // cleanup: remove .to-right from whichever element is now top
  topEl.classList.remove("to-right");
  animating = false;
}


      // Now just listen + render
      onSnapshot(roomRef, (snap) => {
        if (!snap.exists()) return;

        const data = snap.data();

        const deck = Array.isArray(data.deck) ? data.deck : [];
        const order = Array.isArray(data.order) ? data.order : [];
        const idx = typeof data.idx === "number" ? data.idx : 0;

        if (!deckUrls.length || !order.length) return;

        const deckIndex = order[idx] ?? 0;
        const url = deckUrls[deckIndex];


if (!currentUrl) {
  setInstant(url);
  lastIdx = newIdx;
  return;
}

const delta = (lastIdx === null) ? 1 : (newIdx > lastIdx ? 1 : -1);
lastIdx = newIdx;

animateTo(url, delta);

      });
    </script>
  </body>
</html>
