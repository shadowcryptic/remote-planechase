<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Planechase Display</title>

    <style>
      html,
      body {
        margin: 0;
        width: 100%;
        height: 100%;
        background: #000;
        overflow: hidden;
      }
      body {
        display: grid;
        place-items: center;
      }

      .deck {
        width: 680px;
        height: 488px;
        position: relative;
      }

      /* Base card styling + perfect centering */
      .card {
        position: absolute;
        top: 50%;
        left: 50%;

        /* base transform = centered + rotated */
        transform: translate(-50%, -50%) rotate(90deg);

        /* shrink-only (rotated => swap limits) */
        max-width: 488px;
        max-height: 680px;
        width: auto;
        height: auto;
        object-fit: contain;

        border-radius: 14px;
        box-shadow: 0 18px 50px rgba(0, 0, 0, 0.55);
        user-select: none;
        -webkit-user-drag: none;
        will-change: transform;
      }

      /* Roles */
.top {
  z-index: 2;
  transform: translate(-50%, -50%) rotate(90deg) translateX(0) translateZ(0);
}

.under {
  z-index: 1;
  transform: translate(-50%, -50%) rotate(90deg) translateX(0) translateZ(0px);
}

/* NEXT: move current top out to the right (still on top) */
.top.next-out {
  transition: transform 800ms cubic-bezier(0.2, 0.8, 0.2, 1);
  transform: translate(-50%, -50%) rotate(90deg) translateX(500px) translateZ(0);
}

/* NEXT: same element becomes under at-right instantly */
.under.next-park-right {
  transition: none !important;
  transform: translate(-50%, -50%) rotate(90deg) translateX(500px) translateZ(0px);
}

/* NEXT: return under from right -> center */
.under.next-return {
  transition: transform 830ms cubic-bezier(0.2, 0.8, 0.2, 1);
  transform: translate(-50%, -50%) rotate(90deg) translateX(0) translateZ(0px);
}

/* PREV: under slides out to the right while still under */
.under.prev-under-to-right {
  transition: transform 800ms cubic-bezier(0.2, 0.8, 0.2, 1);
  transform: translate(-50%, -50%) rotate(90deg) translateX(500px) translateZ(0px);
}

/* PREV: promote under to "on top at-right" instantly */
.prev-park-right-top {
  transition: none !important;
  z-index: 3;
  transform: translate(-50%, -50%) rotate(90deg) translateX(500px) translateZ(0);
}

/* PREV: return from right -> center on top */
.prev-return-center-top {
  transition: transform 830ms cubic-bezier(0.2, 0.8, 0.2, 1);
  z-index: 3;
  transform: translate(-50%, -50%) rotate(90deg) translateX(0) translateZ(0);
}


      /* Debug overlay (optional) */
      #status {
        position: fixed;
        left: 12px;
        top: 12px;
        z-index: 9999;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
        font-size: 12px;
        color: rgba(255, 255, 255, 0.8);
        background: rgba(0, 0, 0, 0.35);
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 10px;
        padding: 8px 10px;
      }

      @media (prefers-reduced-motion: reduce) {
        .top.to-right,
        .under.return-center,
        .under.under-to-right,
        .top.return-center-top {
          transition: none !important;
        }
      }
    </style>
  </head>

  <body>
    <div id="status">Booting…</div>

    <div class="deck">
      <img id="cardUnder" class="card under" alt="" />
      <img id="cardTop" class="card top" alt="" />
    </div>

    <script type="module">
      import { db, doc, onSnapshot, runTransaction, serverTimestamp } from "./common.js";

      const statusEl = document.getElementById("status");

      const roomRef = doc(db, "rooms", "my-room");

      async function loadDeck() {
        const res = await fetch("./deck.json", { cache: "no-store" });
        if (!res.ok) throw new Error("Failed to load deck.json");
        const data = await res.json();
        return Array.isArray(data.deck) ? data.deck : [];
      }

      function shuffledIndices(n) {
        const a = [];
        for (let i = 0; i < n; i++) a.push(i);
        for (let i = n - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          const tmp = a[i];
          a[i] = a[j];
          a[j] = tmp;
        }
        return a;
      }

let topEl = document.getElementById("cardTop");
let underEl = document.getElementById("cardUnder");

      let deckUrls = [];
      let currentUrl = "";
      let animating = false;
      let lastIdx = null;



function normalizeRoles() {
  topEl.className = "card top";
  underEl.className = "card under";
}

function setInstant(url) {
  topEl.src = url;
  underEl.src = url;
  currentUrl = url;
  normalizeRoles();
}

function waitTransition(el) {
  return new Promise((resolve) => {
    const onEnd = (e) => {
      if (e.propertyName !== "transform") return;
      el.removeEventListener("transitionend", onEnd);
      resolve();
    };
    el.addEventListener("transitionend", onEnd);

    // Safety timeout (in case transitionend doesn't fire)
    window.setTimeout(() => {
      el.removeEventListener("transitionend", onEnd);
      resolve();
    }, 500);
  });
}

function resetClasses() {
  topEl.className = "card top";
  underEl.className = "card under";
  underEl.style.zIndex = ""; // remove any z-index overrides from prev
}

async function animateTo(nextUrl, delta) {
  if (!nextUrl || nextUrl === currentUrl || animating) return;
  animating = true;

  const oldUrl = currentUrl;
  currentUrl = nextUrl;

  normalizeRoles();

  if (delta > 0) {
    // =========================
    // NEXT: top card goes to bottom
    // New top should NEVER move.
    // =========================

    // Put next card underneath (revealed when top slides away)
    underEl.src = nextUrl;

    // Slide current top to the right
    void topEl.offsetWidth;
    topEl.classList.add("to-right");
    await waitTransition(topEl);

    // Swap element references so the new top is now topEl (and stays perfectly still)
    const oldTopEl = topEl;
    topEl = underEl;
    underEl = oldTopEl;

    // New top is already centered; keep it as top (no movement)
    topEl.className = "card top";

    // Old card becomes under, parked at-right-under, then returns under to center
    underEl.className = "card under park-right";
    underEl.src = oldUrl;

    void underEl.offsetWidth;
    underEl.classList.remove("park-right");
    underEl.classList.add("return-center");
    await waitTransition(underEl);

    underEl.className = "card under";
  } else {
    // =========================
    // PREV: current top does NOT move.
    // Only previous card comes up from bottom onto top.
    // =========================

    // Prepare the previous card underneath
    underEl.src = nextUrl;

    // Under card slides out to right (still underneath)
    void underEl.offsetWidth;
    underEl.classList.add("under-to-right");
    await waitTransition(underEl);

    // Promote under card to top at-right instantly, then slide back to center on top
    underEl.className = "card top park-right-top";
    void underEl.offsetWidth;

    underEl.classList.remove("park-right-top");
    underEl.classList.add("return-center-top");
    await waitTransition(underEl);

    // Swap references AFTER the animation so the new top remains the same element
    const oldTopEl = topEl;
    topEl = underEl;
    underEl = oldTopEl;

    // Demote the old top to under (it’s hidden beneath the new top anyway)
    underEl.className = "card under";
    underEl.src = oldUrl;

    // Ensure new top is clean
    topEl.className = "card top";
  }

  animating = false;
}


      // Load deck from repo
      deckUrls = await loadDeck();
      statusEl.textContent = "Deck loaded: " + deckUrls.length;

      // Ensure Firestore order exists and matches deck length
      await runTransaction(db, async (tx) => {
        const snap = await tx.get(roomRef);
        const existing = snap.exists() ? snap.data() : {};
        const order = Array.isArray(existing.order) ? existing.order : [];

        if (order.length !== deckUrls.length && deckUrls.length > 0) {
          tx.set(
            roomRef,
            {
              order: shuffledIndices(deckUrls.length),
              idx: 0,
              shuffledAt: serverTimestamp(),
            },
            { merge: true },
          );
        }
      });

      // Listen for idx/order changes
      onSnapshot(
        roomRef,
        (snap) => {
          if (!snap.exists()) {
            statusEl.textContent = "Room doc not found";
            return;
          }

          const data = snap.data();
          const order = Array.isArray(data.order) ? data.order : [];
          const idx = typeof data.idx === "number" ? data.idx : 0;

          if (!deckUrls.length || !order.length) return;

          const deckIndex = order[idx] ?? 0;
          const url = deckUrls[deckIndex];

          statusEl.textContent = "Card: " + idx + " / " + order.length;

if (!currentUrl) {
  setInstant(url);
  lastIdx = idx;
  return;
}

const deltaRaw = idx - (lastIdx ?? idx);
lastIdx = idx;

if (Math.abs(deltaRaw) !== 1) {
  setInstant(url); // big jumps (reset) snap, no animation
  return;
}

animateTo(url, deltaRaw > 0 ? 1 : -1);

        },
        (err) => {
          statusEl.textContent = "Snapshot error: " + err.message;
        },
      );
    </script>
  </body>
</html>
